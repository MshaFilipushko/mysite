from django.shortcuts import render, get_object_or_404, redirect
from django.views.generic import ListView, DetailView, TemplateView, CreateView, UpdateView, DeleteView, FormView, View
from .models import Category, Post, Recipe, Challenge, UserProfile, ForumCategory, ForumTopic, ForumPost, Comment, RecipeComment, Notification, VIPPost, VIPComment, ContactMessage, FoodCategory, Food, NutritionGoal, MealPlan, Meal, MealItem
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.contrib.auth.views import LoginView, LogoutView, PasswordResetView, PasswordResetDoneView
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth import login, authenticate
from django.contrib import messages
from django.urls import reverse, reverse_lazy
from django.http import JsonResponse, HttpResponse, Http404, HttpResponseRedirect
from django.db.models import Q, Count, F, Max, Prefetch, Sum
from .forms import CustomUserCreationForm as UserRegisterForm, UserProfileForm, CommentForm, UserPostForm, ForumTopicForm, ForumPostForm, RecipeCommentForm, UserRecipeForm, VIPPostForm, VIPCommentForm, NutritionGoalForm, FoodForm, MealPlanForm, MealForm, MealItemForm, QuickFoodForm
import random
import json
import re
import datetime
from django.utils import timezone
from django.utils.text import slugify
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django_ratelimit.decorators import ratelimit
from django.template.loader import render_to_string
import time
from unidecode import unidecode
from django.views.decorators.http import require_POST
from django.utils.decorators import method_decorator
from django.core.exceptions import PermissionDenied
from django.contrib.contenttypes.models import ContentType
from django.views.decorators.csrf import csrf_exempt
from .utils import generate_unique_slug

# Создаем контекстный процессор для уведомлений
def notifications_processor(request):
    context = {}
    if request.user.is_authenticated:
        context['unread_notifications_count'] = Notification.objects.filter(
            recipient=request.user, 
            is_read=False
        ).count()
    
    # Добавляем текущую дату и время
    context['now'] = timezone.now()
    
    return context

# Create your views here.

class HomePageView(TemplateView):
    template_name = 'weightloss/home.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['featured_posts'] = Post.objects.filter(status='published').order_by('-created_on')[:3]
        context['featured_recipes'] = Recipe.objects.filter(status='published').order_by('-created_on')[:3]
        context['challenges'] = Challenge.objects.filter(is_active=True)[:2]
        
        # Добавляем реальное количество пользователей, рецептов и статей
        context['user_count'] = User.objects.count()
        context['recipe_count'] = Recipe.objects.filter(status='published').count()
        context['post_count'] = Post.objects.filter(status='published').count()
        
        return context

class BlogListView(ListView):
    model = Post
    template_name = 'weightloss/blog_list.html'
    context_object_name = 'posts'
    paginate_by = 9  # Показывать 9 постов на странице
    
    def get_queryset(self):
        queryset = Post.objects.filter(status='published')
        
        # Фильтр по автору, если указан
        author_username = self.request.GET.get('author')
        if author_username:
            queryset = queryset.filter(author__username=author_username)
            
        print(f"DEBUG - BlogListView get_queryset: found {queryset.count()} posts with status='published'")
        if queryset.count() > 0:
            for post in queryset:
                print(f"DEBUG - Post '{post.title}' has status '{post.status}' and category '{post.category.name}'")
        else:
            print("DEBUG - No published posts found!")
        return queryset
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        categories = Category.objects.all()
        
        # Add count of published posts for each category
        for category in categories:
            category.published_count = Post.objects.filter(category=category, status='published').count()
            
        context['categories'] = categories
        print(f"DEBUG - BlogListView context: posts={len(context.get('posts', []))}, categories={len(categories)}")
        return context

class BlogDetailView(DetailView):
    model = Post
    template_name = 'weightloss/blog_detail.html'
    context_object_name = 'post'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        post = context['post']
        categories = Category.objects.all()
        related_posts = Post.objects.filter(status='published', category=post.category).exclude(id=post.id)[:3]
        
        # Добавляем недавние статьи для сайдбара
        recent_posts = Post.objects.filter(status='published').order_by('-created_on')[:3]
        
        # Get comments for this post - только комментарии верхнего уровня
        comments = Comment.objects.filter(post=post, parent=None).select_related('author')
        
        # Используем префетч для оптимизации загрузки ответов
        comments = comments.prefetch_related('replies', 'replies__author')
        
        # Подсчет общего количества комментариев, включая вложенные ответы
        total_comments = comments.count()
        for comment in comments:
            # Добавляем количество непосредственных ответов
            replies = comment.replies.all()
            total_comments += replies.count()
            
            # Добавляем количество вложенных ответов на ответы (глубокая вложенность)
            for reply in replies:
                total_comments += reply.replies.count()
                for nested_reply in reply.replies.all():
                    total_comments += nested_reply.replies.count()
        
        # Для каждого комментария подсчитываем все его ответы с учетом вложенных
        for comment in comments:
            comment.total_replies_count = comment.replies.count()
            for reply in comment.replies.all():
                comment.total_replies_count += reply.replies.count()
                for nested_reply in reply.replies.all():
                    comment.total_replies_count += nested_reply.replies.count()
        
        # Add comment form for authenticated users
        if self.request.user.is_authenticated:
            context['comment_form'] = CommentForm()
            
        context.update({
            'categories': categories,
            'related_posts': related_posts,
            'comments': comments,
            'total_comments': total_comments,
            'recent_posts': recent_posts,
        })
        return context
        
    def post(self, request, *args, **kwargs):
        post = self.get_object()
        if request.user.is_authenticated:
            form = CommentForm(request.POST)
            if form.is_valid():
                comment = form.save(commit=False)
                comment.post = post
                comment.author = request.user
                comment.save()
                messages.success(request, 'Ваш комментарий успешно добавлен.')
                return redirect(post.get_absolute_url() + '#comment-' + str(comment.id))
            else:
                messages.error(request, 'Произошла ошибка. Пожалуйста, проверьте введенные данные.')
        return redirect(post.get_absolute_url())

class CategoryDetailView(DetailView):
    model = Category
    template_name = 'weightloss/category_detail.html'
    context_object_name = 'category'
    paginate_by = 9  # Same as BlogListView
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category = self.get_object()
        
        # Get posts for this category
        posts_list = Post.objects.filter(category=category, status='published')
        
        # Add pagination
        page = self.request.GET.get('page', 1)
        paginator = Paginator(posts_list, self.paginate_by)
        
        try:
            posts = paginator.page(page)
        except PageNotAnInteger:
            posts = paginator.page(1)
        except EmptyPage:
            posts = paginator.page(paginator.num_pages)
        
        # Add to context
        context['posts'] = posts
        context['page_obj'] = posts  # For pagination template compatibility
        context['is_paginated'] = True if paginator.num_pages > 1 else False
        context['paginator'] = paginator
        
        # Add all categories for the sidebar
        context['categories'] = Category.objects.all()
        
        return context

class RecipeListView(ListView):
    model = Recipe
    template_name = 'weightloss/recipe_list.html'
    context_object_name = 'recipes'
    paginate_by = 9  # Показывать 9 рецептов на странице
    
    def get_queryset(self):
        queryset = Recipe.objects.filter(status='published')
        
        # Фильтр по автору, если указан
        author_username = self.request.GET.get('author')
        if author_username:
            queryset = queryset.filter(author__username=author_username)
            
        return queryset
        
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Добавляем информацию о выбранном авторе, если есть
        author_username = self.request.GET.get('author')
        if author_username:
            try:
                author = User.objects.get(username=author_username)
                context['filtered_author'] = author
            except User.DoesNotExist:
                pass
                
        return context

class RecipeDetailView(DetailView):
    model = Recipe
    template_name = 'weightloss/recipe_detail.html'
    context_object_name = 'recipe'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        recipe = context['recipe']
        related_recipes = Recipe.objects.exclude(id=recipe.id).order_by('?')[:3]
        
        # Get comments for this recipe - only top-level comments
        comments = RecipeComment.objects.filter(recipe=recipe, parent=None).select_related('author')
        
        # Use prefetch for optimizing loading of replies
        comments = comments.prefetch_related('replies', 'replies__author')
        
        # Add comment form for authenticated users
        if self.request.user.is_authenticated:
            context['comment_form'] = RecipeCommentForm()
            
        context.update({
            'related_recipes': related_recipes,
            'comments': comments,
        })
        return context
        
    def post(self, request, *args, **kwargs):
        recipe = self.get_object()
        if request.user.is_authenticated:
            form = RecipeCommentForm(request.POST)
            if form.is_valid():
                comment = form.save(commit=False)
                comment.recipe = recipe
                comment.author = request.user
                comment.save()
                messages.success(request, 'Ваш комментарий успешно добавлен.')
                return redirect(recipe.get_absolute_url() + '#comment-' + str(comment.id))
            else:
                messages.error(request, 'Произошла ошибка. Пожалуйста, проверьте введенные данные.')
        return redirect(recipe.get_absolute_url())

class ChallengeListView(ListView):
    model = Challenge
    template_name = 'weightloss/challenge_list.html'
    context_object_name = 'challenges'
    paginate_by = 6  # Показывать 6 челленджей на странице
    
    def get_queryset(self):
        return Challenge.objects.filter(is_active=True)

class ChallengeDetailView(DetailView):
    model = Challenge
    template_name = 'weightloss/challenge_detail.html'
    context_object_name = 'challenge'

class CalculatorView(TemplateView):
    template_name = 'weightloss/calculators.html'

class AboutView(TemplateView):
    template_name = 'weightloss/about.html'

class ContactView(View):
    template_name = 'weightloss/contact.html'
    
    def get(self, request, *args, **kwargs):
        return render(request, self.template_name)
    
    def post(self, request, *args, **kwargs):
        name = request.POST.get('name')
        email = request.POST.get('email')
        subject = request.POST.get('subject')
        message = request.POST.get('message')
        
        if name and email and subject and message:
            # Сохраняем сообщение в базе данных
            ContactMessage.objects.create(
                name=name,
                email=email,
                subject=subject,
                message=message
            )
            
            # Возвращаем JSON-ответ для AJAX-запроса
            return JsonResponse({'success': True})
        else:
            # Возвращаем ошибку, если не все поля заполнены
            return JsonResponse({'success': False, 'error': 'Пожалуйста, заполните все поля'})

class SearchResultsView(ListView):
    template_name = 'weightloss/search_results.html'
    context_object_name = 'results'
    paginate_by = 10
    
    def get_queryset(self):
        query = self.request.GET.get('q', '')
        if query:
            post_results = Post.objects.filter(
                Q(title__icontains=query) | Q(content__icontains=query),
                status='published'
            )
            return post_results
        return Post.objects.none()
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        query = self.request.GET.get('q', '')
        if query:
            # The posts are already paginated via ListView
            post_results = context['page_obj'].object_list
            
            # Recipe results - no pagination needed as they're displayed separately
            recipe_results = Recipe.objects.filter(
                Q(title__icontains=query) | Q(ingredients__icontains=query) | Q(instructions__icontains=query),
                status='published'
            )
            
            context['results'] = {
                'posts': post_results,
                'recipes': recipe_results,
                'query': query,
                'total_posts': self.get_queryset().count(),
                'total_recipes': recipe_results.count()
            }
        else:
            context['results'] = {'posts': [], 'recipes': [], 'query': '', 'total_posts': 0, 'total_recipes': 0}
        return context

# Авторизация и регистрация

class CustomLoginView(LoginView):
    template_name = 'weightloss/auth/login.html'
    
    def get_success_url(self):
        return reverse_lazy('profile')

class CustomLogoutView(LogoutView):
    next_page = 'home'
    http_method_names = ['get', 'post']  # Разрешаем как GET, так и POST-запросы

class RegisterView(FormView):
    template_name = 'weightloss/auth/register.html'
    form_class = UserRegisterForm
    success_url = reverse_lazy('home')
    
    def form_valid(self, form):
        user = form.save()
        UserProfile.objects.create(user=user)
        login(self.request, user)
        return super().form_valid(form)

class CustomPasswordResetView(PasswordResetView):
    template_name = 'weightloss/auth/password_reset.html'
    email_template_name = 'weightloss/auth/password_reset_email.html'
    success_url = reverse_lazy('password_reset_done')

class CustomPasswordResetDoneView(PasswordResetDoneView):
    template_name = 'weightloss/auth/password_reset_done.html'

class ProfileView(LoginRequiredMixin, TemplateView):
    template_name = 'weightloss/profile.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        try:
            profile = UserProfile.objects.get(user=self.request.user)
        except UserProfile.DoesNotExist:
            profile = UserProfile.objects.create(user=self.request.user)
        
        context['profile'] = profile
        context['bmi'] = profile.bmi()
        context['user_posts'] = Post.objects.filter(author=self.request.user).order_by('-created_on')[:5]
        return context

class UserProfileDetailView(DetailView):
    model = UserProfile
    template_name = 'weightloss/public_profile.html'
    context_object_name = 'profile'
    
    def get_object(self):
        username = self.kwargs.get('username')
        user = get_object_or_404(User, username=username)
        profile, created = UserProfile.objects.get_or_create(user=user)
        return profile
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        profile = self.get_object()
        user = profile.user
        
        # Получаем публичную информацию о пользователе
        context['user_posts'] = Post.objects.filter(author=user, status='published').order_by('-created_on')[:5]
        context['user_recipes'] = Recipe.objects.filter(author=user, status='published').order_by('-created_on')[:5]
        context['forum_topics'] = ForumTopic.objects.filter(author=user).order_by('-created_on')[:5]
        context['bmi'] = profile.bmi()
        
        # Подсчитываем активность пользователя
        context['posts_count'] = Post.objects.filter(author=user, status='published').count()
        context['recipes_count'] = Recipe.objects.filter(author=user, status='published').count()
        context['forum_posts_count'] = ForumPost.objects.filter(author=user).count()
        context['comments_count'] = Comment.objects.filter(author=user).count() + RecipeComment.objects.filter(author=user).count()
        
        return context

class EditProfileView(LoginRequiredMixin, UpdateView):
    model = UserProfile
    form_class = UserProfileForm
    template_name = 'weightloss/auth/edit_profile.html'
    success_url = reverse_lazy('profile')
    
    def get_object(self):
        try:
            return UserProfile.objects.get(user=self.request.user)
        except UserProfile.DoesNotExist:
            return UserProfile.objects.create(user=self.request.user)
    
    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, 'Профиль успешно обновлен!')
        return response

# Представления для пользовательских статей
class UserPostsListView(LoginRequiredMixin, ListView):
    model = Post
    template_name = 'weightloss/blog/user_posts.html'
    context_object_name = 'posts'
    paginate_by = 10  # Показывать 10 постов на странице
    
    def get_queryset(self):
        return Post.objects.filter(author=self.request.user).order_by('-created_on')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user_posts = self.get_queryset()
        
        # Add filtered posts by status
        context['published_posts'] = user_posts.filter(status='published')
        context['pending_posts'] = user_posts.filter(status='pending')
        context['draft_posts'] = user_posts.filter(status='draft')
        context['rejected_posts'] = user_posts.filter(status='rejected')
        
        return context

class UserPostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = UserPostForm
    template_name = 'weightloss/user_post_form.html'
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        form.instance.is_user_submitted = True
        form.instance.status = 'pending'  # Устанавливаем статус "на модерации"
        
        # Используем улучшенную функцию генерации slug
        form.instance.slug = generate_unique_slug(Post, form.instance.title)
        
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('user_posts')

class UserPostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Post
    form_class = UserPostForm
    template_name = 'weightloss/user_post_form.html'
    
    def test_func(self):
        post = self.get_object()
        return post.author == self.request.user
    
    def form_valid(self, form):
        # Если пост был опубликован или отклонен, и пользователь его редактирует,
        # его следует вернуть на модерацию
        post = self.get_object()
        if post.status in ['published', 'rejected']:
            form.instance.status = 'pending'
        
        if 'featured_image' in self.request.FILES:
            form.instance.featured_image = self.request.FILES['featured_image']
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('user_posts')

# Представления для форума
class ForumHomeView(ListView):
    model = ForumCategory
    template_name = 'weightloss/forum/forum_home.html'
    context_object_name = 'categories'
    
    def get_queryset(self):
        return ForumCategory.objects.annotate(
            topics_count=Count('topics'),
            posts_count=Count('topics__forum_posts'),
            last_post_date=Max('topics__forum_posts__created_on')
        ).order_by('order')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Статистика форума
        context['topic_count'] = ForumTopic.objects.count()
        context['reply_count'] = ForumPost.objects.count()
        context['member_count'] = User.objects.count()
        
        # Последний зарегистрированный пользователь
        try:
            context['latest_member'] = User.objects.latest('date_joined')
        except User.DoesNotExist:
            context['latest_member'] = None
            
        return context

class ForumCategoryView(DetailView):
    model = ForumCategory
    template_name = 'weightloss/forum/forum_category.html'
    context_object_name = 'category'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category = self.get_object()
        
        # Сортируем темы
        topics_list = ForumTopic.objects.filter(category=category).annotate(
            last_post_date=Max('forum_posts__created_on')
        ).select_related('author').order_by('-is_pinned', '-updated_on')
        
        # Добавляем пагинацию
        page = self.request.GET.get('page', 1)
        paginator = Paginator(topics_list, 10)  # Показывать 10 тем на странице
        
        try:
            topics = paginator.page(page)
        except PageNotAnInteger:
            topics = paginator.page(1)
        except EmptyPage:
            topics = paginator.page(paginator.num_pages)
        
        context['topics'] = topics
        context['page_obj'] = topics  # Для совместимости с шаблоном пагинации
        return context

class ForumTopicDetailView(DetailView):
    model = ForumTopic
    template_name = 'weightloss/forum/forum_topic_detail.html'
    context_object_name = 'topic'
    slug_url_kwarg = 'slug'
    
    def get_object(self):
        category_slug = self.kwargs.get('category_slug')
        topic_slug = self.kwargs.get('slug')
        topic = get_object_or_404(ForumTopic, slug=topic_slug, category__slug=category_slug)
        if not self.request.session.get(f'topic_viewed_{topic.id}'):
            topic.views += 1
            topic.save()
            self.request.session[f'topic_viewed_{topic.id}'] = True
        return topic
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        topic = self.get_object()
        
        # Получаем все посты темы верхнего уровня
        posts_list = ForumPost.objects.filter(topic=topic, parent=None).select_related('author')
        
        # Используем префетч для оптимизации загрузки ответов
        posts_list = posts_list.prefetch_related('replies', 'replies__author', 'replies__replies', 'replies__replies__replies')
        
        # Для каждого поста подсчитываем все его ответы с учетом вложенных
        for post in posts_list:
            # Улучшенный рекурсивный подсчет всех вложенных ответов
            post.total_replies_count = self._count_nested_replies(post)
        
        # Добавляем пагинацию
        page = self.request.GET.get('page', 1)
        paginator = Paginator(posts_list, 10)  # Показывать 10 постов на странице
        
        try:
            posts = paginator.page(page)
        except PageNotAnInteger:
            posts = paginator.page(1)
        except EmptyPage:
            posts = paginator.page(paginator.num_pages)
        
        context['posts'] = posts
        context['total_posts_count'] = posts_list.count()  # Добавляем общее количество постов
        context['form'] = ForumPostForm()
        
        # Добавляем все категории форума для отображения в боковой панели
        context['forum_categories'] = ForumCategory.objects.all().order_by('order')
        
        return context
    
    def _count_nested_replies(self, post):
        """
        Рекурсивно подсчитывает все вложенные ответы для поста.
        """
        total = post.replies.count()
        
        # Рекурсивно обрабатываем все ответы
        for reply in post.replies.all():
            total += self._count_nested_replies(reply)
            
        return total

class ForumTopicCreateView(LoginRequiredMixin, CreateView):
    model = ForumTopic
    form_class = ForumTopicForm
    template_name = 'weightloss/forum/forum_topic_form.html'
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        
        # Если передана категория в URL
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            category = get_object_or_404(ForumCategory, slug=category_slug)
            form.instance.category = category
        
        # Используем улучшенную функцию генерации slug
        form.instance.slug = generate_unique_slug(ForumTopic, form.instance.title)
        
        # Save the form to create the topic
        self.object = form.save(commit=True, user=self.request.user)
        
        return HttpResponseRedirect(self.get_success_url())
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            context['category'] = get_object_or_404(ForumCategory, slug=category_slug)
        return context
    
    def get_success_url(self):
        return self.object.get_absolute_url()

class ForumPostCreateView(LoginRequiredMixin, CreateView):
    model = ForumPost
    form_class = ForumPostForm
    template_name = 'weightloss/forum/forum_post_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        
        # Check if this is a reply to another post
        parent_id = self.request.GET.get('reply_to')
        if parent_id:
            try:
                parent_post = ForumPost.objects.get(id=parent_id)
                kwargs['parent_post'] = parent_post
            except ForumPost.DoesNotExist:
                pass
                
        return kwargs
    
    def form_valid(self, form):
        topic = get_object_or_404(
            ForumTopic, 
            slug=self.kwargs.get('topic_slug'),
            category__slug=self.kwargs.get('category_slug')
        )
        
        if topic.is_closed:
            return HttpResponseRedirect(topic.get_absolute_url())
        
        form.instance.topic = topic
        form.instance.author = self.request.user
        
        # Set parent post if this is a reply
        parent_id = self.request.GET.get('reply_to')
        if parent_id:
            try:
                parent_post = ForumPost.objects.get(id=parent_id)
                form.instance.parent = parent_post
            except ForumPost.DoesNotExist:
                pass
        
        # Обновляем дату последнего обновления темы
        topic.updated_on = timezone.now()
        topic.save()
        
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        topic = get_object_or_404(
            ForumTopic, 
            slug=self.kwargs.get('topic_slug'),
            category__slug=self.kwargs.get('category_slug')
        )
        context['topic'] = topic
        
        # Add parent post to context if replying
        parent_id = self.request.GET.get('reply_to')
        if parent_id:
            try:
                context['parent_post'] = ForumPost.objects.get(id=parent_id)
            except ForumPost.DoesNotExist:
                pass
                
        return context
    
    def get_success_url(self):
        return self.object.get_absolute_url()

class CommentReplyView(LoginRequiredMixin, CreateView):
    model = Comment
    form_class = CommentForm
    template_name = 'weightloss/blog/comment_reply_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        parent_id = self.kwargs.get('comment_id')
        if parent_id:
            try:
                parent_comment = Comment.objects.get(id=parent_id)
                kwargs['parent_comment'] = parent_comment
            except Comment.DoesNotExist:
                raise Http404("Комментарий не найден")
        return kwargs
    
    def form_valid(self, form):
        parent_id = self.kwargs.get('comment_id')
        post_slug = self.kwargs.get('slug')
        
        try:
            post = Post.objects.get(slug=post_slug)
            parent_comment = Comment.objects.get(id=parent_id)
            
            # Добавляем отладку
            is_nested = parent_comment.parent is not None
            parent_of_parent_id = parent_comment.parent.id if is_nested else None
            print(f"Creating reply to comment {parent_id}")
            print(f"Is this a reply to a reply? {is_nested}")
            if is_nested:
                print(f"Original parent comment ID: {parent_of_parent_id}")
            
            # Убираем ограничение на глубину вложенности - теперь комментарии могут быть любой глубины
            # Это убрано, так как мы поддерживаем любой уровень вложенности в шаблоне
            """
            if is_nested:
                # We're replying to a reply already
                # Find the original parent of this reply
                original_parent = parent_comment.parent
                
                # If the original parent already has a parent (i.e., it's a 3rd level reply)
                # we want to keep our comment as a 2nd level reply attached to the top level comment
                if original_parent.parent is not None:
                    print(f"Limiting nesting depth - attaching to original parent {original_parent.parent.id}")
                    parent_comment = original_parent.parent
                else:
                    print(f"Setting parent to original parent {original_parent.id}")
                    parent_comment = original_parent
            """
            
        except (Post.DoesNotExist, Comment.DoesNotExist):
            raise Http404("Пост или комментарий не найден")
        
        form.instance.post = post
        form.instance.author = self.request.user
        form.instance.parent = parent_comment  # Устанавливаем родительский комментарий
        self.object = form.save()
        
        # Еще отладка после сохранения
        print(f"Created comment {self.object.id} with parent {self.object.parent.id}")
        
        messages.success(self.request, 'Ваш ответ успешно добавлен.')
        return HttpResponseRedirect(self.get_success_url())
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        parent_id = self.kwargs.get('comment_id')
        post_slug = self.kwargs.get('slug')
        
        try:
            context['post'] = Post.objects.get(slug=post_slug)
            context['parent_comment'] = Comment.objects.get(id=parent_id)
        except (Post.DoesNotExist, Comment.DoesNotExist):
            raise Http404("Пост или комментарий не найден")
            
        return context
    
    def get_success_url(self):
        return self.object.post.get_absolute_url() + '#comment-' + str(self.object.id)

# Представления для пользовательских рецептов
class UserRecipesListView(LoginRequiredMixin, ListView):
    model = Recipe
    template_name = 'weightloss/recipe/user_recipes.html'
    context_object_name = 'recipes'
    paginate_by = 10  # Показывать 10 рецептов на странице
    
    def get_queryset(self):
        return Recipe.objects.filter(author=self.request.user).order_by('-created_on')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        recipes = self.get_queryset()
        
        # Подсчет количества рецептов с разными статусами
        context['pending_count'] = recipes.filter(status='pending').count()
        context['published_count'] = recipes.filter(status='published').count()
        context['rejected_count'] = recipes.filter(status='rejected').count()
        context['draft_count'] = recipes.filter(status='draft').count()
        
        return context

class UserRecipeCreateView(LoginRequiredMixin, CreateView):
    model = Recipe
    form_class = UserRecipeForm
    template_name = 'weightloss/recipe/user_recipe_form.html'
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        form.instance.is_user_submitted = True
        form.instance.status = 'pending'  # Устанавливаем статус "на модерации"
        
        # Явно создаём человекопонятный slug
        form.instance.slug = generate_unique_slug(Recipe, form.instance.title)
        
        return super().form_valid(form)
    
    def get_success_url(self):
        messages.success(self.request, 'Ваш рецепт отправлен на модерацию и будет опубликован после проверки.')
        return reverse('user_recipes')

class UserRecipeUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Recipe
    form_class = UserRecipeForm
    template_name = 'weightloss/recipe/user_recipe_form.html'
    
    def test_func(self):
        recipe = self.get_object()
        return recipe.author == self.request.user
    
    def form_valid(self, form):
        # Если рецепт был опубликован или отклонен, и пользователь его редактирует,
        # его следует вернуть на модерацию
        recipe = self.get_object()
        if recipe.status in ['published', 'rejected']:
            form.instance.status = 'pending'
        
        return super().form_valid(form)
    
    def get_success_url(self):
        messages.success(self.request, 'Ваш рецепт успешно обновлен и отправлен на повторную модерацию.')
        return reverse('user_recipes')

class UserRecipeDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    model = Recipe
    template_name = 'weightloss/recipe/user_recipe_confirm_delete.html'
    success_url = reverse_lazy('user_recipes')
    
    def test_func(self):
        recipe = self.get_object()
        return recipe.author == self.request.user

# Административные представления для рецептов (только для персонала)
class AdminRecipeListView(LoginRequiredMixin, UserPassesTestMixin, ListView):
    model = Recipe
    template_name = 'weightloss/recipe/admin_recipe_list.html'
    context_object_name = 'recipes'
    paginate_by = 15  # Показывать 15 рецептов на странице
    
    def test_func(self):
        return self.request.user.is_staff
    
    def get_queryset(self):
        status = self.request.GET.get('status', 'pending')
        return Recipe.objects.filter(status=status).order_by('-created_on')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['status'] = self.request.GET.get('status', 'pending')
        
        # Подсчет количества рецептов с разными статусами
        context['pending_count'] = Recipe.objects.filter(status='pending').count()
        context['published_count'] = Recipe.objects.filter(status='published').count()
        context['rejected_count'] = Recipe.objects.filter(status='rejected').count()
        
        return context

class AdminRecipeUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = Recipe
    template_name = 'weightloss/recipe/admin_recipe_form.html'
    fields = ['title', 'calories', 'protein', 'carbs', 'fat', 'preparation_time', 'image', 'ingredients', 'instructions', 'status', 'is_featured']
    
    def test_func(self):
        return self.request.user.is_staff
    
    def get_success_url(self):
        messages.success(self.request, f'Рецепт "{self.object.title}" успешно обновлен.')
        return reverse('admin_recipe_list') + f'?status={self.object.status}'

class ForumSearchView(ListView):
    template_name = 'weightloss/forum/forum_search.html'
    context_object_name = 'topics'
    paginate_by = 10  # Показывать 10 результатов на странице
    
    def get_queryset(self):
        query = self.request.GET.get('q', '')
        if query:
            # Поиск по названию темы или содержанию постов
            topics = ForumTopic.objects.filter(
                Q(title__icontains=query) | 
                Q(content__icontains=query) |
                Q(forum_posts__content__icontains=query)
            ).distinct()
            return topics
        return ForumTopic.objects.none()
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['query'] = self.request.GET.get('q', '')
        return context

class RecipeCommentReplyView(LoginRequiredMixin, CreateView):
    model = RecipeComment
    form_class = RecipeCommentForm
    template_name = 'weightloss/recipe/recipe_comment_reply_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        parent_id = self.kwargs.get('comment_id')
        if parent_id:
            try:
                parent_comment = RecipeComment.objects.get(id=parent_id)
                kwargs['parent_comment'] = parent_comment
            except RecipeComment.DoesNotExist:
                raise Http404("Комментарий не найден")
        return kwargs
    
    def form_valid(self, form):
        parent_id = self.kwargs.get('comment_id')
        recipe_slug = self.kwargs.get('slug')
        
        try:
            recipe = Recipe.objects.get(slug=recipe_slug)
            parent_comment = RecipeComment.objects.get(id=parent_id)
            
            # Add debugging
            is_nested = parent_comment.parent is not None
            parent_of_parent_id = parent_comment.parent.id if is_nested else None
            
            print(f"Creating reply to recipe comment {parent_id}")
            print(f"Is this a reply to a reply? {is_nested}")
            if is_nested:
                print(f"Original parent comment ID: {parent_of_parent_id}")
            
            # Убираем ограничение на глубину вложенности - поддерживаем любой уровень вложенности
            """
            # Fix for deeply nested comments - find the original top-level parent
            # only go 2 levels deep at most (replies to replies)
            if is_nested:
                # We're replying to a reply already
                # Find the original parent of this reply
                original_parent = parent_comment.parent
                
                # If the original parent already has a parent (i.e., it's a 3rd level reply)
                # we want to keep our comment as a 2nd level reply attached to the top level comment
                if original_parent.parent is not None:
                    print(f"Limiting nesting depth - attaching to original parent {original_parent.parent.id}")
                    parent_comment = original_parent.parent
                else:
                    print(f"Setting parent to original parent {original_parent.id}")
                    parent_comment = original_parent
            """
                
        except (Recipe.DoesNotExist, RecipeComment.DoesNotExist):
            raise Http404("Рецепт или комментарий не найден")
        
        form.instance.recipe = recipe
        form.instance.author = self.request.user
        form.instance.parent = parent_comment
        self.object = form.save()
        
        # More debugging after saving
        print(f"Created comment {self.object.id} with parent {self.object.parent.id}")
        
        messages.success(self.request, 'Ваш ответ успешно добавлен.')
        return HttpResponseRedirect(self.get_success_url())
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        parent_id = self.kwargs.get('comment_id')
        recipe_slug = self.kwargs.get('slug')
        
        try:
            context['recipe'] = Recipe.objects.get(slug=recipe_slug)
            context['parent_comment'] = RecipeComment.objects.get(id=parent_id)
        except (Recipe.DoesNotExist, RecipeComment.DoesNotExist):
            raise Http404("Рецепт или комментарий не найден")
            
        return context
    
    def get_success_url(self):
        return self.object.recipe.get_absolute_url() + '#comment-' + str(self.object.id)

# Юридические страницы
class PrivacyPolicyView(TemplateView):
    template_name = 'weightloss/legal/privacy_policy.html'

class TermsOfServiceView(TemplateView):
    template_name = 'weightloss/legal/terms_of_service.html'

class CookiePolicyView(TemplateView):
    template_name = 'weightloss/legal/cookie_policy.html'

# SEO представления
class RobotsView(TemplateView):
    template_name = 'robots.txt'
    content_type = 'text/plain'

# Временное представление для отладки проблемы блога
class TestBlogView(TemplateView):
    template_name = 'weightloss/test_blog.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        all_posts = Post.objects.all()
        published_posts = Post.objects.filter(status='published')
        
        context['all_posts'] = all_posts
        context['published_posts'] = published_posts
        context['debug_mode'] = True
        
        return context
        
    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        
        # Если запрошен ответ JSON
        if request.GET.get('format') == 'json':
            from django.http import JsonResponse
            
            posts_data = []
            for post in context['published_posts']:
                posts_data.append({
                    'id': post.id,
                    'title': post.title,
                    'slug': post.slug,
                    'status': post.status,
                    'category': post.category.name,
                    'author': post.author.username,
                    'created': str(post.created_on),
                })
            
            return JsonResponse({
                'total_posts': context['all_posts'].count(),
                'published_posts': context['published_posts'].count(),
                'posts': posts_data
            })
        
        return super().get(request, *args, **kwargs)

class ForumPostReplyView(LoginRequiredMixin, View):
    """
    Обработка AJAX-запросов на добавление ответов к постам в форуме
    """
    def post(self, request, post_id):
        print(f"ForumPostReplyView: получен запрос на ответ к посту {post_id}")
        print(f"POST данные: {request.POST}")
        
        try:
            parent_post = get_object_or_404(ForumPost, id=post_id)
            topic = parent_post.topic
            
            if topic.is_closed:
                print(f"Ошибка: тема {topic.id} закрыта для новых ответов")
                return JsonResponse({
                    'status': 'error',
                    'message': 'This topic is closed for new replies.'
                }, status=403)
            
            content = request.POST.get('content', '').strip()
            if not content:
                print("Ошибка: содержимое ответа пустое")
                return JsonResponse({
                    'status': 'error',
                    'message': 'Reply content cannot be empty.'
                }, status=400)
            
            # Создаем новый ответ
            print(f"Создаем новый ответ к посту {post_id}, автор: {request.user.username}")
            reply = ForumPost.objects.create(
                topic=topic,
                author=request.user,
                parent=parent_post,
                content=content
            )
            
            # Обновляем дату последнего обновления темы
            topic.updated_on = timezone.now()
            topic.save()
            
            # Рендерим HTML для нового ответа
            level = 1
            if parent_post.parent:  # Если отвечаем на вложенный ответ
                level = 2  # Для простоты ограничимся двумя уровнями вложенности
            
            print(f"Рендерим шаблон single_reply.html для ответа {reply.id}, уровень {level}")
            try:
                html = render_to_string('weightloss/forum/single_reply.html', {
                    'reply': reply,
                    'level': level,
                    'user': request.user
                }, request=request)
                print(f"Шаблон успешно отрендерен, длина HTML: {len(html)}")
            except Exception as e:
                print(f"Ошибка при рендеринге шаблона: {str(e)}")
                html = f"<div>Ответ добавлен, но не может быть отображен. Обновите страницу.</div>"
            
            return JsonResponse({
                'status': 'success',
                'html': html,
                'reply_id': reply.id,
                'parent_id': parent_post.id,
                'total_replies': parent_post.total_replies_count()
            })
        except Exception as e:
            print(f"Необработанная ошибка в ForumPostReplyView: {str(e)}")
            import traceback
            traceback.print_exc()
            return JsonResponse({
                'status': 'error',
                'message': f'Внутренняя ошибка сервера: {str(e)}'
            }, status=500)

class ForumPostDeleteView(LoginRequiredMixin, View):
    """
    Обработка AJAX-запросов на удаление ответов в форуме
    """
    def post(self, request, post_id):
        post = get_object_or_404(ForumPost, id=post_id)
        
        # Проверяем, может ли пользователь удалить этот пост
        if request.user.id != post.author.id and not request.user.is_staff:
            return JsonResponse({
                'status': 'error',
                'message': 'У вас нет прав для удаления этого ответа'
            }, status=403)
        
        # Получаем родительский пост для обновления счетчика ответов
        parent_post = post.parent
        parent_id = parent_post.id if parent_post else None
        
        # Удаляем пост и все его ответы рекурсивно
        post.delete()
        
        # Возвращаем обновленное количество ответов, если есть родительский пост
        if parent_post:
            return JsonResponse({
                'status': 'success',
                'parent_id': parent_id,
                'total_replies': parent_post.total_replies_count()
            })
        else:
            return JsonResponse({
                'status': 'success'
            })

# Представления для уведомлений
class NotificationListView(LoginRequiredMixin, ListView):
    model = Notification
    template_name = 'weightloss/notifications/notification_list.html'
    context_object_name = 'notifications'
    paginate_by = 20
    
    def get_queryset(self):
        return Notification.objects.filter(recipient=self.request.user).order_by('-created_at')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Отмечаем все уведомления как прочитанные при просмотре списка
        Notification.objects.filter(recipient=self.request.user, is_read=False).update(is_read=True)
        return context

@login_required
def mark_notification_as_read(request, pk):
    try:
        notification = Notification.objects.get(pk=pk, recipient=request.user)
        notification.mark_as_read()
        
        # Если передан URL для перенаправления, перенаправляем туда
        next_url = request.GET.get('next')
        if next_url and notification.url:
            return HttpResponseRedirect(notification.url)
        elif next_url:
            return HttpResponseRedirect(next_url)
        else:
            return HttpResponseRedirect(reverse('notifications'))
    except Notification.DoesNotExist:
        raise Http404("Уведомление не найдено")

@login_required
def mark_all_notifications_read(request):
    Notification.objects.filter(recipient=request.user, is_read=False).update(is_read=True)
    
    next_url = request.GET.get('next')
    if next_url:
        return HttpResponseRedirect(next_url)
    else:
        return HttpResponseRedirect(reverse('notifications'))

@login_required
def get_unread_notifications_count(request):
    """
    API-метод для получения количества непрочитанных уведомлений
    через AJAX
    """
    count = Notification.objects.filter(recipient=request.user, is_read=False).count()
    return JsonResponse({'count': count})

# VIP Views
class VIPUserRequired(UserPassesTestMixin):
    """Миксин для проверки, что пользователь имеет VIP-статус"""
    def test_func(self):
        return self.request.user.is_authenticated and hasattr(self.request.user, 'profile') and self.request.user.profile.has_active_vip()

    def handle_no_permission(self):
        return render(self.request, 'weightloss/vip/vip_access_denied.html')

class VIPListView(LoginRequiredMixin, View):
    def get(self, request, *args, **kwargs):
        # Проверяем, есть ли у пользователя доступ VIP
        if hasattr(request.user, 'profile') and request.user.profile.has_active_vip():
            vip_posts = VIPPost.objects.all().order_by('-created_on')
            return render(request, 'weightloss/vip/vip_list.html', {
                'vip_posts': vip_posts,
                'is_admin': request.user.is_staff  # Добавляем флаг админа в контекст
            })
        else:
            # Если нет доступа VIP, показываем страницу с информацией о получении доступа
            return render(request, 'weightloss/vip/vip_access_denied.html')

class VIPDetailView(LoginRequiredMixin, View):
    def get(self, request, slug, *args, **kwargs):
        # Проверяем, есть ли у пользователя доступ VIP
        if hasattr(request.user, 'profile') and request.user.profile.has_active_vip():
            vip_post = get_object_or_404(VIPPost, slug=slug)
            
            # Получаем комментарии только верхнего уровня
            comments = vip_post.comments.filter(parent=None).select_related('author')
            
            # Используем prefetch для оптимизации загрузки ответов
            comments = comments.prefetch_related('replies', 'replies__author', 'replies__replies', 'replies__replies__author')
            
            # Подсчет общего количества комментариев, включая вложенные ответы
            total_comments = comments.count()
            for comment in comments:
                # Добавляем количество непосредственных ответов
                replies = comment.replies.all()
                total_comments += replies.count()
                
                # Добавляем количество вложенных ответов на ответы (глубокая вложенность)
                for reply in replies:
                    total_comments += reply.replies.count()
                    for nested_reply in reply.replies.all():
                        total_comments += nested_reply.replies.count()
            
            # Для каждого комментария подсчитываем все его ответы с учетом вложенных
            for comment in comments:
                comment.total_replies_count = comment.replies.count()
                for reply in comment.replies.all():
                    comment.total_replies_count += reply.replies.count()
                    for nested_reply in reply.replies.all():
                        comment.total_replies_count += nested_reply.replies.count()
            
            return render(request, 'weightloss/vip/vip_detail.html', {
                'post': vip_post,
                'comments': comments,
                'total_comments': total_comments,
                'comment_form': VIPCommentForm()
            })
        else:
            # Если нет доступа VIP, показываем страницу с информацией о получении доступа
            return render(request, 'weightloss/vip/vip_access_denied.html')
    
    def post(self, request, slug, *args, **kwargs):
        # Проверяем, есть ли у пользователя доступ VIP
        if hasattr(request.user, 'profile') and request.user.profile.has_active_vip():
            vip_post = get_object_or_404(VIPPost, slug=slug)
            form = VIPCommentForm(request.POST)
            
            if form.is_valid():
                new_comment = form.save(commit=False)
                new_comment.post = vip_post
                new_comment.author = request.user
                new_comment.save()
                
                # Создаем уведомление для автора статьи
                if request.user != vip_post.author:
                    Notification.objects.create(
                        recipient=vip_post.author,
                        sender=request.user,
                        content_object=vip_post,
                        notification_type='comment',
                        message=f'{request.user.username} оставил(а) комментарий к вашей VIP-статье "{vip_post.title}"'
                    )
                
                return redirect('vip_detail', slug=slug)
            
            comments = vip_post.comments.filter(parent=None).order_by('created_on')
            return render(request, 'weightloss/vip/vip_detail.html', {
                'post': vip_post,
                'comments': comments,
                'comment_form': form
            })
        else:
            # Если нет доступа VIP, показываем страницу с информацией о получении доступа
            return render(request, 'weightloss/vip/vip_access_denied.html')

class VIPCommentReplyView(LoginRequiredMixin, VIPUserRequired, View):
    def post(self, request, slug, comment_id, *args, **kwargs):
        vip_post = get_object_or_404(VIPPost, slug=slug)
        parent_comment = get_object_or_404(VIPComment, id=comment_id)
        form = VIPCommentForm(request.POST, parent_comment=parent_comment)
        
        if form.is_valid():
            new_comment = form.save(commit=False)
            new_comment.post = vip_post
            new_comment.author = request.user
            new_comment.save()
            
            # Создаем уведомление для автора родительского комментария
            if request.user != parent_comment.author:
                Notification.objects.create(
                    recipient=parent_comment.author,
                    sender=request.user,
                    content_object=vip_post,
                    notification_type='reply',
                    message=f'{request.user.username} ответил(а) на ваш комментарий к VIP-статье "{vip_post.title}"'
                )
            
            return redirect('vip_detail', slug=slug)
        
        return redirect('vip_detail', slug=slug)

class VIPPostCreateView(LoginRequiredMixin, UserPassesTestMixin, CreateView):
    model = VIPPost
    form_class = VIPPostForm
    template_name = 'weightloss/vip/vip_post_form.html'
    
    def test_func(self):
        return self.request.user.is_staff
    
    def handle_no_permission(self):
        return redirect('vip_list')
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Сохраняем форму без коммита, чтобы получить экземпляр
        self.object = form.save(commit=False, user=self.request.user)
        # Убедимся, что slug существует и не пустой
        if not self.object.slug:
            from django.utils.text import slugify
            import random
            import string
            base_slug = slugify(self.object.title)
            if not base_slug:
                random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
                base_slug = f"vip-post-{random_string}"
            
            self.object.slug = base_slug
            
            # Проверяем уникальность слага
            counter = 1
            original_slug = self.object.slug
            while VIPPost.objects.filter(slug=self.object.slug).exists():
                self.object.slug = f"{original_slug}-{counter}"
                counter += 1
                
        # Теперь сохраняем объект
        self.object.save()
        return HttpResponseRedirect(self.get_success_url())
    
    def get_success_url(self):
        messages.success(self.request, 'VIP-статья успешно создана.')
        return reverse('vip_list')

class VIPPostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    model = VIPPost
    form_class = VIPPostForm
    template_name = 'weightloss/vip/vip_post_form.html'
    
    def test_func(self):
        return self.request.user.is_staff
    
    def handle_no_permission(self):
        return redirect('vip_list')
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        # Сохраняем форму без коммита, чтобы получить экземпляр
        self.object = form.save(commit=False, user=self.request.user)
        # Убедимся, что slug существует и не пустой
        if not self.object.slug:
            from django.utils.text import slugify
            import random
            import string
            base_slug = slugify(self.object.title)
            if not base_slug:
                random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
                base_slug = f"vip-post-{random_string}"
            
            self.object.slug = base_slug
            
            # Проверяем уникальность слага
            counter = 1
            original_slug = self.object.slug
            while VIPPost.objects.filter(slug=self.object.slug).exclude(pk=self.object.pk).exists():
                self.object.slug = f"{original_slug}-{counter}"
                counter += 1
                
        # Теперь сохраняем объект
        self.object.save()
        return HttpResponseRedirect(self.get_success_url())
    
    def get_success_url(self):
        messages.success(self.request, 'VIP-статья успешно обновлена.')
        return reverse('vip_list')

class VIPPostDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    model = VIPPost
    template_name = 'weightloss/vip/vip_post_confirm_delete.html'
    success_url = reverse_lazy('vip_list')
    
    def test_func(self):
        return self.request.user.is_staff
    
    def handle_no_permission(self):
        return redirect('vip_list')

class VIPCommentReplyFormView(LoginRequiredMixin, VIPUserRequired, CreateView):
    model = VIPComment
    form_class = VIPCommentForm
    template_name = 'weightloss/vip/vip_comment_reply_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        parent_id = self.kwargs.get('comment_id')
        if parent_id:
            try:
                parent_comment = VIPComment.objects.get(id=parent_id)
                kwargs['parent_comment'] = parent_comment
            except VIPComment.DoesNotExist:
                raise Http404("Комментарий не найден")
        return kwargs
    
    def form_valid(self, form):
        parent_id = self.kwargs.get('comment_id')
        post_slug = self.kwargs.get('slug')
        
        try:
            vip_post = VIPPost.objects.get(slug=post_slug)
            parent_comment = VIPComment.objects.get(id=parent_id)
            
        except (VIPPost.DoesNotExist, VIPComment.DoesNotExist):
            raise Http404("VIP-статья или комментарий не найдены")
        
        form.instance.post = vip_post
        form.instance.author = self.request.user
        form.instance.parent = parent_comment
        self.object = form.save()
        
        # Создаем уведомление для автора родительского комментария
        if self.request.user != parent_comment.author:
            Notification.objects.create(
                recipient=parent_comment.author,
                sender=self.request.user,
                content_object=vip_post,
                notification_type='reply',
                message=f'{self.request.user.username} ответил(а) на ваш комментарий к VIP-статье "{vip_post.title}"'
            )
        
        messages.success(self.request, 'Ваш ответ успешно добавлен.')
        return HttpResponseRedirect(self.get_success_url())
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        parent_id = self.kwargs.get('comment_id')
        post_slug = self.kwargs.get('slug')
        
        try:
            context['post'] = VIPPost.objects.get(slug=post_slug)
            context['parent_comment'] = VIPComment.objects.get(id=parent_id)
        except (VIPPost.DoesNotExist, VIPComment.DoesNotExist):
            raise Http404("VIP-статья или комментарий не найдены")
            
        return context
    
    def get_success_url(self):
        return self.object.post.get_absolute_url() + '#comment-' + str(self.object.id)
        
        
def logout_view(request):
    """Функция для выхода из системы, работающая с POST-запросами"""
    if request.method == 'POST':
        from django.contrib.auth import logout
        logout(request)
    return redirect('home')

# Представления для плана питания
class NutritionCalculatorView(View):
    template_name = 'weightloss/meal_plan/calculator.html'
    
    def get(self, request, *args, **kwargs):
        form = NutritionGoalForm()
        return render(request, self.template_name, {'form': form})
    
    def post(self, request, *args, **kwargs):
        form = NutritionGoalForm(request.POST)
        if form.is_valid():
            if request.user.is_authenticated:
                goal = form.save(commit=False)
                goal.user = request.user
                goal.save()
                return redirect('nutrition_goal_detail', pk=goal.pk)
            else:
                # Для неавторизованных пользователей - просто показываем результаты
                goal = form.save(commit=False)
                return render(request, 'weightloss/meal_plan/calculator_results.html', {'goal': goal})
        
        return render(request, self.template_name, {'form': form})

class NutritionGoalListView(LoginRequiredMixin, ListView):
    model = NutritionGoal
    template_name = 'weightloss/meal_plan/nutrition_goal_list.html'
    context_object_name = 'goals'
    
    def get_queryset(self):
        return NutritionGoal.objects.filter(user=self.request.user)

class NutritionGoalCreateView(LoginRequiredMixin, CreateView):
    model = NutritionGoal
    form_class = NutritionGoalForm
    template_name = 'weightloss/meal_plan/nutrition_goal_form.html'
    
    def form_valid(self, form):
        form.instance.user = self.request.user
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('nutrition_goal_detail', kwargs={'pk': self.object.pk})

class NutritionGoalDetailView(LoginRequiredMixin, DetailView):
    model = NutritionGoal
    template_name = 'weightloss/meal_plan/nutrition_goal_detail.html'
    context_object_name = 'goal'
    
    def get_queryset(self):
        return NutritionGoal.objects.filter(user=self.request.user)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Добавляем список планов питания, связанных с этой целью
        context['meal_plans'] = self.object.meal_plans.all()
        return context

class NutritionGoalUpdateView(LoginRequiredMixin, UpdateView):
    model = NutritionGoal
    form_class = NutritionGoalForm
    template_name = 'weightloss/meal_plan/nutrition_goal_form.html'
    
    def get_queryset(self):
        return NutritionGoal.objects.filter(user=self.request.user)
    
    def get_success_url(self):
        return reverse('nutrition_goal_detail', kwargs={'pk': self.object.pk})

class NutritionGoalDeleteView(LoginRequiredMixin, DeleteView):
    model = NutritionGoal
    template_name = 'weightloss/meal_plan/nutrition_goal_confirm_delete.html'
    
    def get_queryset(self):
        return NutritionGoal.objects.filter(user=self.request.user)
    
    def get_success_url(self):
        return reverse('nutrition_goal_list')

class MealPlanListView(ListView):
    model = MealPlan
    template_name = 'weightloss/meal_plan/meal_plan_list.html'
    context_object_name = 'meal_plans'
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return MealPlan.objects.filter(user=self.request.user)
        return MealPlan.objects.none()
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        if self.request.user.is_authenticated:
            context['nutrition_goals'] = NutritionGoal.objects.filter(user=self.request.user)
        return context

class MealPlanCreateView(LoginRequiredMixin, CreateView):
    model = MealPlan
    form_class = MealPlanForm
    template_name = 'weightloss/meal_plan/meal_plan_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def form_valid(self, form):
        form.instance.user = self.request.user
        response = super().form_valid(form)
        
        # После сохранения плана питания автоматически создаем стандартные приемы пищи для каждого дня
        meal_types = ['breakfast', 'lunch', 'dinner', 'snack']
        days_of_week = range(1, 8)  # 1-7 (Понедельник - Воскресенье)
        
        for day in days_of_week:
            for meal_type in meal_types:
                Meal.objects.create(
                    plan=self.object,
                    meal_type=meal_type,
                    day_of_week=day
                )
        
        return response
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.pk})

class MealPlanDetailView(DetailView):
    model = MealPlan
    template_name = 'weightloss/meal_plan/meal_plan_detail.html'
    context_object_name = 'meal_plan'
    
    def get_queryset(self):
        if self.request.user.is_authenticated:
            return MealPlan.objects.filter(user=self.request.user)
        return MealPlan.objects.none()
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        meal_plan = self.object
        
        # Группировка блюд по дням недели
        days_of_week = {}
        days_totals = {}  # Словарь для хранения итогов по дням
        
        for meal in meal_plan.meals.all():
            day = meal.day_of_week
            if day not in days_of_week:
                days_of_week[day] = []
                days_totals[day] = {
                    'calories': 0,
                    'protein': 0,
                    'fats': 0,
                    'carbs': 0
                }
            days_of_week[day].append(meal)
            
            # Суммируем значения для дня
            days_totals[day]['calories'] += meal.total_calories()
            days_totals[day]['protein'] += meal.total_protein()
            days_totals[day]['fats'] += meal.total_fats()
            days_totals[day]['carbs'] += meal.total_carbs()
        
        # Создаем список кортежей (день, блюда, итоги)
        days_data = []
        for day, meals in sorted(days_of_week.items()):
            days_data.append((day, meals, days_totals[day]))
        
        # Добавляем в контекст
        context['days_data'] = days_data
        
        # Сортировка дней недели (сохраняем для обратной совместимости)
        context['days_of_week'] = sorted(days_of_week.items())
        
        # Подсчет общих макронутриентов
        context['total_calories'] = meal_plan.total_calories()
        context['total_protein'] = meal_plan.total_protein()
        context['total_fats'] = meal_plan.total_fats()
        context['total_carbs'] = meal_plan.total_carbs()
        
        # Добавление формы для создания приема пищи
        context['meal_form'] = MealForm()
        
        return context

class MealPlanUpdateView(LoginRequiredMixin, UpdateView):
    model = MealPlan
    form_class = MealPlanForm
    template_name = 'weightloss/meal_plan/meal_plan_form.html'
    
    def get_queryset(self):
        return MealPlan.objects.filter(user=self.request.user)
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.pk})

class MealPlanDeleteView(LoginRequiredMixin, DeleteView):
    model = MealPlan
    template_name = 'weightloss/meal_plan/meal_plan_confirm_delete.html'
    
    def get_queryset(self):
        return MealPlan.objects.filter(user=self.request.user)
    
    def get_success_url(self):
        return reverse('meal_plan_list')

class MealCreateView(LoginRequiredMixin, CreateView):
    model = Meal
    form_class = MealForm
    template_name = 'weightloss/meal_plan/meal_form.html'
    
    def dispatch(self, request, *args, **kwargs):
        self.meal_plan = get_object_or_404(MealPlan, pk=kwargs['plan_id'], user=request.user)
        return super().dispatch(request, *args, **kwargs)
    
    def form_valid(self, form):
        form.instance.plan = self.meal_plan
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['meal_plan'] = self.meal_plan
        return context
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.meal_plan.pk})

class MealUpdateView(LoginRequiredMixin, UpdateView):
    model = Meal
    form_class = MealForm
    template_name = 'weightloss/meal_plan/meal_form.html'
    
    def get_queryset(self):
        return Meal.objects.filter(plan__user=self.request.user)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['meal_plan'] = self.object.plan
        return context
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.plan.pk})

class MealDeleteView(LoginRequiredMixin, DeleteView):
    model = Meal
    template_name = 'weightloss/meal_plan/meal_confirm_delete.html'
    
    def get_queryset(self):
        return Meal.objects.filter(plan__user=self.request.user)
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.plan.pk})

class MealItemCreateView(LoginRequiredMixin, CreateView):
    model = MealItem
    form_class = MealItemForm
    template_name = 'weightloss/meal_plan/meal_item_form.html'
    
    def dispatch(self, request, *args, **kwargs):
        self.meal = get_object_or_404(Meal, pk=kwargs['meal_id'], plan__user=request.user)
        return super().dispatch(request, *args, **kwargs)
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def form_valid(self, form):
        form.instance.meal = self.meal
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['meal'] = self.meal
        context['meal_plan'] = self.meal.plan
        context['quick_food_form'] = QuickFoodForm()
        
        # Добавляем данные о продуктах для JavaScript
        # Получаем все доступные продукты
        foods = Food.objects.filter(
            Q(is_custom=False) | Q(is_custom=True, user=self.request.user)
        )
        # Преобразуем в JSON для передачи в шаблон
        foods_json = []
        for food in foods:
            foods_json.append({
                'id': food.id,
                'name': food.name,
                'calories': food.calories,
                'protein': food.protein,
                'fat': food.fats,
                'carbs': food.carbs
            })
        context['foods_json'] = json.dumps(foods_json)
        
        return context
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.meal.plan.pk})

class MealItemUpdateView(LoginRequiredMixin, UpdateView):
    model = MealItem
    form_class = MealItemForm
    template_name = 'weightloss/meal_plan/meal_item_form.html'
    
    def get_queryset(self):
        return MealItem.objects.filter(meal__plan__user=self.request.user)
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['meal'] = self.object.meal
        context['meal_plan'] = self.object.meal.plan
        
        # Добавляем данные о продуктах для JavaScript
        # Получаем все доступные продукты
        foods = Food.objects.filter(
            Q(is_custom=False) | Q(is_custom=True, user=self.request.user)
        )
        # Преобразуем в JSON для передачи в шаблон
        foods_json = []
        for food in foods:
            foods_json.append({
                'id': food.id,
                'name': food.name,
                'calories': food.calories,
                'protein': food.protein,
                'fat': food.fats,
                'carbs': food.carbs
            })
        context['foods_json'] = json.dumps(foods_json)
        
        return context
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.meal.plan.pk})

class MealItemDeleteView(LoginRequiredMixin, DeleteView):
    model = MealItem
    template_name = 'weightloss/meal_plan/meal_item_confirm_delete.html'
    
    def get_queryset(self):
        return MealItem.objects.filter(meal__plan__user=self.request.user)
    
    def get_success_url(self):
        return reverse('meal_plan_detail', kwargs={'pk': self.object.meal.plan.pk})

class FoodListView(ListView):
    model = Food
    template_name = 'weightloss/meal_plan/food_list.html'
    context_object_name = 'foods'
    paginate_by = 20
    
    def get_queryset(self):
        queryset = Food.objects.filter(Q(is_custom=False) | Q(is_custom=True, user=self.request.user))
        
        # Поиск
        search_query = self.request.GET.get('search', '').strip()
        if search_query:
            print(f"Поисковый запрос: '{search_query}'")
            # Улучшенный поиск - делаем "грубое" сравнение строк с неявной кодировкой
            matching_foods = []
            search_query_lower = search_query.lower()
            print(f"Поисковый запрос в нижнем регистре: '{search_query_lower}'")
            
            for food in queryset:
                # Преобразуем имя продукта в нижний регистр для сравнения
                food_name_lower = food.name.lower()
                
                # Если поисковый запрос содержится в имени продукта
                if search_query_lower in food_name_lower:
                    matching_foods.append(food.id)
                    print(f"Найдено совпадение: '{food.name}' (ID: {food.id})")
            
            # Фильтруем queryset по найденным ID
            if matching_foods:
                print(f"Найдено {len(matching_foods)} совпадений с помощью улучшенного поиска")
                queryset = queryset.filter(id__in=matching_foods)
            else:
                # Если ничего не найдено с нашим методом, все равно попробуем стандартный
                print("Улучшенный поиск не дал результатов, пробуем стандартный")
                queryset = queryset.filter(name__icontains=search_query)
                print(f"Стандартный поиск вернул {queryset.count()} результатов")
        
        # Фильтрация по категории
        category_id = self.request.GET.get('category', '')
        if category_id and category_id.isdigit():
            queryset = queryset.filter(category_id=category_id)
        
        return queryset.order_by('name')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['categories'] = FoodCategory.objects.all()
        context['search_form'] = self.request.GET.get('search', '')
        context['selected_category'] = self.request.GET.get('category', '')
        
        # Подсчитываем количество продуктов в каждой категории
        categories_with_counts = []
        for category in context['categories']:
            count = Food.objects.filter(
                Q(category=category) & 
                (Q(is_custom=False) | Q(is_custom=True, user=self.request.user))
            ).count()
            categories_with_counts.append((category, count))
        
        context['categories_with_counts'] = categories_with_counts
        
        return context

class FoodCreateView(LoginRequiredMixin, CreateView):
    model = Food
    form_class = FoodForm
    template_name = 'weightloss/meal_plan/food_form.html'
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def form_valid(self, form):
        form.instance.is_custom = True
        form.instance.user = self.request.user
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('food_list')

class FoodUpdateView(LoginRequiredMixin, UpdateView):
    model = Food
    form_class = FoodForm
    template_name = 'weightloss/meal_plan/food_form.html'
    
    def get_queryset(self):
        # Пользователь может редактировать только свои собственные продукты
        return Food.objects.filter(is_custom=True, user=self.request.user)
    
    def get_success_url(self):
        return reverse('food_list')

class FoodDeleteView(LoginRequiredMixin, DeleteView):
    model = Food
    template_name = 'weightloss/meal_plan/food_confirm_delete.html'
    
    def get_queryset(self):
        # Пользователь может удалять только свои собственные продукты
        return Food.objects.filter(is_custom=True, user=self.request.user)
    
    def get_success_url(self):
        return reverse('food_list')

class FoodCategoryListView(ListView):
    model = FoodCategory
    template_name = 'weightloss/meal_plan/food_category_list.html'
    context_object_name = 'categories'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Подсчитываем количество продуктов в каждой категории
        categories_with_counts = []
        for category in context['categories']:
            count = Food.objects.filter(
                Q(category=category) & 
                (Q(is_custom=False) | Q(is_custom=True, user=self.request.user))
            ).count()
            categories_with_counts.append((category, count))
        
        context['categories_with_counts'] = categories_with_counts
        
        return context

# API для плана питания
@csrf_exempt
def nutrition_calculate_api(request):
    """API для расчета питательных веществ без сохранения"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            
            # Проверяем наличие всех необходимых данных
            required_fields = ['gender', 'age', 'height', 'weight', 'activity_level', 'goal']
            for field in required_fields:
                if field not in data:
                    return JsonResponse({
                        'error': f'Отсутствует обязательное поле: {field}'
                    }, status=400)
            
            gender = data.get('gender')
            if gender not in ['male', 'female']:
                return JsonResponse({
                    'error': 'Некорректное значение пола. Допустимые значения: male, female'
                }, status=400)
                
            try:
                age = int(data.get('age', 0))
                height = int(data.get('height', 0))
                weight = float(data.get('weight', 0))
            except (ValueError, TypeError):
                return JsonResponse({
                    'error': 'Некорректные числовые значения для возраста, роста или веса'
                }, status=400)
                
            if age <= 0 or height <= 0 or weight <= 0:
                return JsonResponse({
                    'error': 'Возраст, рост и вес должны быть положительными числами'
                }, status=400)
                
            activity_level = data.get('activity_level')
            valid_activities = ['sedentary', 'light', 'moderate', 'active', 'very_active']
            if activity_level not in valid_activities:
                return JsonResponse({
                    'error': f'Некорректный уровень активности. Допустимые значения: {", ".join(valid_activities)}'
                }, status=400)
                
            goal = data.get('goal')
            valid_goals = ['maintain', 'lose_slow', 'lose_medium', 'lose_fast', 'gain_slow', 'gain_medium', 'gain_fast']
            if goal not in valid_goals:
                return JsonResponse({
                    'error': f'Некорректная цель. Допустимые значения: {", ".join(valid_goals)}'
                }, status=400)
            
            # Расчет базовых калорий (формула Миффлина-Сент Жеора)
            if gender == 'male':
                base_calories = int((10 * weight) + (6.25 * height) - (5 * age) + 5)
            else:
                base_calories = int((10 * weight) + (6.25 * height) - (5 * age) - 161)
            
            # Коэффициент активности
            activity_multiplier = {
                'sedentary': 1.2,
                'light': 1.375,
                'moderate': 1.55,
                'active': 1.725,
                'very_active': 1.9
            }.get(activity_level, 1.2)
            
            # Коррекция по цели
            goal_modifier = {
                'maintain': 1.0,
                'lose_slow': 0.9,
                'lose_medium': 0.85,
                'lose_fast': 0.8,
                'gain_slow': 1.1,
                'gain_medium': 1.15,
                'gain_fast': 1.2,
            }.get(goal, 1.0)
            
            target_calories = int(base_calories * activity_multiplier * goal_modifier)
            
            # Расчет макронутриентов
            if 'lose' in goal:
                protein_per_kg = 1.8
            elif 'gain' in goal:
                protein_per_kg = 2.0
            else:
                protein_per_kg = 1.6
            
            protein_daily = round(protein_per_kg * weight, 1)
            fats_per_kg = 0.9
            fats_daily = round(fats_per_kg * weight, 1)
            
            protein_calories = protein_daily * 4
            fat_calories = fats_daily * 9
            carbs_calories = target_calories - protein_calories - fat_calories
            carbs_daily = round(carbs_calories / 4, 1)
            
            # Проверяем, что получилось ненулевое значение углеводов
            if carbs_daily < 0:
                carbs_daily = 0
            
            return JsonResponse({
                'base_calories': base_calories,
                'target_calories': target_calories,
                'protein_daily': protein_daily,
                'fats_daily': fats_daily,
                'carbs_daily': carbs_daily
            })
        except Exception as e:
            return JsonResponse({
                'error': f'Произошла ошибка при расчете: {str(e)}'
            }, status=500)
    
    return JsonResponse({'error': 'Метод не разрешен'}, status=405)

@login_required
def food_search_api(request):
    """API для поиска продуктов"""
    if request.method == 'GET':
        query = request.GET.get('query', '').strip()
        category_id = request.GET.get('category', '')
        
        queryset = Food.objects.filter(Q(is_custom=False) | Q(is_custom=True, user=request.user))
        
        if query:
            # Улучшенный поиск - делаем "грубое" сравнение строк с неявной кодировкой
            matching_foods = []
            query_lower = query.lower()
            
            for food in queryset:
                # Преобразуем имя продукта в нижний регистр для сравнения
                food_name_lower = food.name.lower()
                
                # Если поисковый запрос содержится в имени продукта
                if query_lower in food_name_lower:
                    matching_foods.append(food.id)
            
            # Фильтруем queryset по найденным ID
            if matching_foods:
                queryset = queryset.filter(id__in=matching_foods)
            else:
                # Если ничего не найдено с нашим методом, все равно попробуем стандартный
                queryset = queryset.filter(name__icontains=query)
        
        if category_id and category_id.isdigit():
            queryset = queryset.filter(category_id=category_id)
        
        foods = []
        for food in queryset[:20]:  # Ограничиваем результаты
            foods.append({
                'id': food.id,
                'name': food.name,
                'calories': food.calories,
                'protein': food.protein,
                'fats': food.fats,
                'carbs': food.carbs,
                'category': {
                    'id': food.category.id,
                    'name': food.category.name
                }
            })
        
        return JsonResponse({'foods': foods})
    
    return JsonResponse({'error': 'Метод не разрешен'}, status=405)

@login_required
@csrf_exempt
def food_create_api(request):
    """API для быстрого создания продукта"""
    if request.method == 'POST':
        data = json.loads(request.body)
        form = QuickFoodForm(data)
        
        if form.is_valid():
            food = form.save(commit=False)
            food.user = request.user
            food.is_custom = True
            food.save()
            
            return JsonResponse({
                'success': True,
                'food': {
                    'id': food.id,
                    'name': food.name,
                    'calories': food.calories,
                    'protein': food.protein,
                    'fats': food.fats,
                    'carbs': food.carbs,
                    'category': {
                        'id': food.category.id,
                        'name': food.category.name
                    }
                }
            })
        else:
            return JsonResponse({
                'success': False,
                'errors': form.errors
            }, status=400)
    
    return JsonResponse({'error': 'Метод не разрешен'}, status=405)

@login_required
@csrf_exempt
def meal_plan_auto_fill(request, meal_plan_id):
    """
    Автоматически заполняет план питания продуктами в соответствии с целями по КБЖУ
    с учетом следующих правил совместимости:
    - В один прием пищи нельзя добавлять два разных вида мяса
    - В один прием пищи нельзя добавлять мясо и рыбу одновременно
    - В один прием пищи можно добавлять только один вид рыбы
    - В один прием пищи можно добавлять только один вид крупы
    - Основные приемы пищи имеют структуру: белок + крупа/картофель + овощи/фрукты
    - Перекусы состоят из легких продуктов (йогурт, фрукты, орехи)
    """
    print(f"Получен запрос на автозаполнение плана {meal_plan_id} от пользователя {request.user}")
    print(f"Метод запроса: {request.method}")
    
    if request.method != 'POST':
        print("Ошибка: Метод запроса не POST")
        messages.error(request, 'Требуется POST запрос')
        return redirect('meal_plan_detail', pk=meal_plan_id)
    
    # Получаем план питания
    try:
        meal_plan = MealPlan.objects.get(pk=meal_plan_id, user=request.user)
        print(f"План питания найден: {meal_plan.name}")
    except MealPlan.DoesNotExist:
        print(f"Ошибка: План питания с ID {meal_plan_id} не найден")
        messages.error(request, 'План питания не найден')
        return redirect('meal_plan_list')
    
    # Получаем цель по питанию
    nutrition_goal = meal_plan.nutrition_goal
    if not nutrition_goal:
        print("Ошибка: Отсутствует цель по питанию для этого плана")
        messages.error(request, 'Для автозаполнения необходимо указать цель по питанию')
        return redirect('meal_plan_detail', pk=meal_plan_id)
    
    # Получаем все продукты
    foods = Food.objects.all()
    if foods.count() < 5:
        print("Ошибка: Недостаточно продуктов в базе данных")
        messages.error(request, 'Для автозаполнения необходимо добавить хотя бы 5 продуктов')
        return redirect('meal_plan_detail', pk=meal_plan_id)
    
    # Получаем все приемы пищи плана
    meals = Meal.objects.filter(plan=meal_plan)
    
    # Распределение макронутриентов по приемам пищи
    meal_distribution = {
        'breakfast': {'calories': 0.25, 'protein': 0.25, 'fats': 0.2, 'carbs': 0.3},
        'lunch': {'calories': 0.35, 'protein': 0.35, 'fats': 0.3, 'carbs': 0.35},
        'dinner': {'calories': 0.3, 'protein': 0.3, 'fats': 0.35, 'carbs': 0.25},
        'snack': {'calories': 0.1, 'protein': 0.1, 'fats': 0.15, 'carbs': 0.1},
    }
    
    # Удаляем все существующие продукты из приемов пищи
    MealItem.objects.filter(meal__in=meals).delete()
    print("Удалены все существующие продукты из плана питания")
    
    # Распределяем продукты по приемам пищи
    for meal in meals:
        meal_type = meal.meal_type
        if meal_type not in meal_distribution:
            continue
        
        distribution = meal_distribution[meal_type]
        
        # Вычисляем целевые значения для этого приема пищи
        target_calories = nutrition_goal.target_calories * distribution['calories']
        target_protein = nutrition_goal.protein_daily * distribution['protein']
        target_fats = nutrition_goal.fats_daily * distribution['fats']
        target_carbs = nutrition_goal.carbs_daily * distribution['carbs']
        
        print(f"Подбор продуктов для {meal.get_meal_type_display()} на {meal.get_day_of_week_display()}")
        print(f"Целевые значения: К: {target_calories:.1f} ккал, Б: {target_protein:.1f}г, Ж: {target_fats:.1f}г, У: {target_carbs:.1f}г")
        
        # Подбираем продукты для этого приема пищи
        selected_foods = get_foods_for_meal(foods, target_calories, target_protein, target_fats, target_carbs)
        
        # Добавляем выбранные продукты в прием пищи
        for food, amount in selected_foods:
            # Создаем элемент приема пищи
            MealItem.objects.create(
                meal=meal,
                food=food,
                amount=amount,
            )
            print(f"Добавлен продукт {food.name} ({amount}г) к {meal.get_meal_type_display()} на {meal.get_day_of_week_display()}")
    
    print("Автозаполнение плана питания завершено")
    
    return redirect('meal_plan_detail', pk=meal_plan_id)

def get_foods_for_meal(foods, target_calories, target_protein, target_fats, target_carbs):
    """
    Функция подбора продуктов для приема пищи
    с учетом целевых показателей по КБЖУ
    и следующих правил совместимости:
    - В один прием пищи нельзя добавлять два разных вида мяса
    - В один прием пищи нельзя добавлять мясо и рыбу одновременно
    - В один прием пищи можно добавлять только один вид рыбы
    - В один прием пищи можно добавлять только один вид крупы
    - Основные приемы пищи должны иметь структуру: белок + крупа/картофель + овощи/фрукты
    - Перекусы должны быть легкими (йогурт, фрукты, орехи)
    """
    import random
    
    print(f"Целевые значения: Калории: {target_calories:.1f}, Белки: {target_protein:.1f}г, Жиры: {target_fats:.1f}г, Углеводы: {target_carbs:.1f}г")
    
    # Получаем категории продуктов по их названиям
    meat_categories = list(FoodCategory.objects.filter(name__icontains='Мясо'))
    fish_categories = list(FoodCategory.objects.filter(name__icontains='Рыба'))
    grains_categories = list(FoodCategory.objects.filter(name__icontains='Крупы'))
    vegetable_categories = list(FoodCategory.objects.filter(name__icontains='Овощи'))
    fruit_categories = list(FoodCategory.objects.filter(name__icontains='Фрукты'))
    dairy_categories = list(FoodCategory.objects.filter(name__icontains='Молоч'))
    nuts_categories = list(FoodCategory.objects.filter(name__icontains='Орехи'))
    
    # Получаем идентификаторы категорий для удобного поиска
    meat_category_ids = [cat.id for cat in meat_categories]
    fish_category_ids = [cat.id for cat in fish_categories]
    grains_category_ids = [cat.id for cat in grains_categories]
    vegetable_category_ids = [cat.id for cat in vegetable_categories]
    fruit_category_ids = [cat.id for cat in fruit_categories]
    dairy_category_ids = [cat.id for cat in dairy_categories]
    nuts_category_ids = [cat.id for cat in nuts_categories]
    
    print(f"Категории мяса: {meat_category_ids}")
    print(f"Категории рыбы: {fish_category_ids}")
    print(f"Категории круп: {grains_category_ids}")
    print(f"Категории овощей: {vegetable_category_ids}")
    print(f"Категории фруктов: {fruit_category_ids}")
    print(f"Категории молочных: {dairy_category_ids}")
    print(f"Категории орехов: {nuts_category_ids}")
    
    # Если категории не найдены, установим их вручную на основе известных названий
    if not meat_category_ids:
        meat_categories_by_name = FoodCategory.objects.filter(name__in=["Мясо и птица", "Мясо"])
        meat_category_ids = [cat.id for cat in meat_categories_by_name]
    
    if not fish_category_ids:
        fish_categories_by_name = FoodCategory.objects.filter(name__in=["Рыба и морепродукты", "Рыба", "Морепродукты"])
        fish_category_ids = [cat.id for cat in fish_categories_by_name]
    
    if not grains_category_ids:
        grains_categories_by_name = FoodCategory.objects.filter(name__in=["Крупы и злаки", "Крупы", "Злаки"])
        grains_category_ids = [cat.id for cat in grains_categories_by_name]
        
    if not vegetable_category_ids:
        vegetable_categories_by_name = FoodCategory.objects.filter(name__in=["Овощи"])
        vegetable_category_ids = [cat.id for cat in vegetable_categories_by_name]
        
    if not fruit_category_ids:
        fruit_categories_by_name = FoodCategory.objects.filter(name__in=["Фрукты и ягоды", "Фрукты", "Ягоды"])
        fruit_category_ids = [cat.id for cat in fruit_categories_by_name]
        
        if not dairy_category_ids:        dairy_categories_by_name = FoodCategory.objects.filter(name__in=["Молочные продукты", "Молочка"])        dairy_category_ids = [cat.id for cat in dairy_categories_by_name]        if not nuts_category_ids:        nuts_categories_by_name = FoodCategory.objects.filter(name__in=["Орехи и семена", "Орехи"])        nuts_category_ids = [cat.id for cat in nuts_categories_by_name]        # Определяем, это перекус или основной приём пищи    is_snack = target_calories < 300  # Если калорий меньше 300, считаем это перекусом        # Проверяем, похоже ли это на завтрак по количеству калорий    is_breakfast = 400 <= target_calories <= 700  # Предположительно завтрак по калориям
    
    # Отбираем подходящие продукты по типам, берем больше продуктов для лучшего подбора
    protein_foods = list(foods.filter(protein__gt=10).order_by('?')[:25])  # продукты с высоким содержанием белка
    fat_foods = list(foods.filter(fats__gt=10).order_by('?')[:25])  # продукты с высоким содержанием жиров
    carb_foods = list(foods.filter(carbs__gt=15).order_by('?')[:25])  # продукты с высоким содержанием углеводов
    
    # Создаем специализированные списки продуктов для разных категорий
    meat_foods = list(foods.filter(category_id__in=meat_category_ids).order_by('?')[:15])
    fish_foods = list(foods.filter(category_id__in=fish_category_ids).order_by('?')[:15])
    grain_foods = list(foods.filter(category_id__in=grains_category_ids).order_by('?')[:15])
    vegetable_foods = list(foods.filter(category_id__in=vegetable_category_ids).order_by('?')[:15])
    fruit_foods = list(foods.filter(category_id__in=fruit_category_ids).order_by('?')[:15])
    dairy_foods = list(foods.filter(category_id__in=dairy_category_ids).order_by('?')[:15])
    nuts_foods = list(foods.filter(category_id__in=nuts_category_ids).order_by('?')[:15])
    
    # Для перекусов выбираем подходящие продукты
    snack_foods = dairy_foods + fruit_foods + nuts_foods
    
    # Объединяем все продукты, убираем дубликаты и перемешиваем
    all_foods = protein_foods + fat_foods + carb_foods + vegetable_foods + fruit_foods + dairy_foods + nuts_foods
    unique_foods = []
    food_ids = set()
    
    for food in all_foods:
        if food.id not in food_ids:
            food_ids.add(food.id)
            unique_foods.append(food)
    random.shuffle(unique_foods)
    
    # Если продуктов меньше 3, не удастся нормально заполнить
    if len(unique_foods) < 3:
        return []
    
    # Создаем начальную популяцию из потенциальных комбинаций продуктов
    population_size = 20  # Увеличиваем размер популяции для большего разнообразия
    population = []
    
    for _ in range(population_size):
        selected_foods = []
        current_calories = 0
        current_protein = 0
        current_fats = 0
        current_carbs = 0
        
        # Отслеживаем, какие категории продуктов уже выбраны
        has_meat = False
        has_fish = False
        has_grain = False
        has_vegetable = False
        has_fruit = False
        has_dairy = False
        has_nuts = False
        fish_count = 0
        grain_count = 0
        meat_types = set()
        fish_types = set()
        grain_types = set()
        
        # Структура приема пищи зависит от того, это перекус или основной прием
        if is_snack:
            # Перекус: 1-2 легких продукта (молочные, фрукты, орехи)
            # Добавляем молочный продукт (например, йогурт или кефир)
            if dairy_foods:
                food = random.choice(dairy_foods)
                # Устанавливаем меньшее количество для перекуса
                amount = random.choice([100, 150, 200])
                
                selected_foods.append((food, amount))
                calorie_factor = amount / 100.0
                current_calories += food.calories * calorie_factor
                current_protein += food.protein * calorie_factor
                current_fats += food.fats * calorie_factor
                current_carbs += food.carbs * calorie_factor
                has_dairy = True
            
            # Добавляем фрукты или ягоды
            if fruit_foods and random.random() < 0.7:  # 70% шанс добавить фрукты/ягоды
                food = random.choice(fruit_foods)
                amount = random.choice([50, 100, 150])
                
                selected_foods.append((food, amount))
                calorie_factor = amount / 100.0
                current_calories += food.calories * calorie_factor
                current_protein += food.protein * calorie_factor
                current_fats += food.fats * calorie_factor
                current_carbs += food.carbs * calorie_factor
                has_fruit = True
            
            # Добавляем орехи или семена (небольшое количество)
            if nuts_foods and random.random() < 0.4:  # 40% шанс добавить орехи/семена
                food = random.choice(nuts_foods)
                # Для орехов маленькие порции, т.к. они калорийные
                amount = random.choice([10, 15, 20])
                
                selected_foods.append((food, amount))
                calorie_factor = amount / 100.0
                current_calories += food.calories * calorie_factor
                current_protein += food.protein * calorie_factor
                current_fats += food.fats * calorie_factor
                current_carbs += food.carbs * calorie_factor
                                has_nuts = True        elif is_breakfast:            # Специальная структура для завтрака - реалистичный человеческий завтрак                        # 1. Сначала добавляем основу для завтрака (каша, хлопья, тосты)            if grain_foods and not has_grain and grain_count == 0:                # Отбираем подходящие для завтрака крупы (овсянка, хлопья, и т.д.)                breakfast_grains = [f for f in grain_foods if any(name in f.name.lower() for name in                                    ["овсян", "хлопья", "мюсли", "каша", "хлеб", "тост", "булк", "рис", "злак"])]                                if breakfast_grains:                    food = random.choice(breakfast_grains)                else:                    food = random.choice(grain_foods)                                    # Более крупная порция для основного компонента завтрака                amount = random.choice([40, 50, 60])                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_grain = True                grain_count += 1                grain_types.add(food.name)                        # 2. Добавляем молочный продукт (молоко, йогурт, творог)            if dairy_foods and not has_dairy:                # Отбираем подходящие для завтрака молочные продукты                breakfast_dairy = [f for f in dairy_foods if any(name in f.name.lower() for name in                                  ["молок", "йогурт", "творог", "кефир", "ряженк", "сметан"])]                                if breakfast_dairy:                    food = random.choice(breakfast_dairy)                else:                    food = random.choice(dairy_foods)                                    # Типичная порция молочного продукта на завтрак                if "молок" in food.name.lower():                    amount = random.choice([150, 200, 250])                else:                    amount = random.choice([100, 150, 200])                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_dairy = True                        # 3. Добавляем фрукты или ягоды как традиционный компонент завтрака            if fruit_foods and not has_fruit:                food = random.choice(fruit_foods)                amount = random.choice([50, 100, 150])                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_fruit = True                        # 4. С некоторой вероятностью добавляем яйца или небольшую порцию белка            if random.random() < 0.5:  # 50% шанс                # Ищем яйца среди продуктов                eggs = [f for f in foods if "яйц" in f.name.lower()]                                if eggs:                    food = random.choice(eggs)                    amount = random.choice([25, 50])  # 0.5-1 яйцо                elif meat_foods:                    # Если нет яиц, добавляем небольшую порцию мяса                    food = random.choice(meat_foods)                    amount = random.choice([20, 30, 40])  # Маленькая порция                else:                    # Пропускаем, если нет подходящих продуктов                    food = None                                if food:                    selected_foods.append((food, amount))                    calorie_factor = amount / 100.0                    current_calories += food.calories * calorie_factor                    current_protein += food.protein * calorie_factor                    current_fats += food.fats * calorie_factor                    current_carbs += food.carbs * calorie_factor                                        if "яйц" not in food.name.lower() and food.category_id in meat_category_ids:                        has_meat = True                        meat_types.add(food.name)                        # 5. С некоторой вероятностью добавляем орехи или сухофрукты            if random.random() < 0.3 and nuts_foods:  # 30% шанс                food = random.choice(nuts_foods)                amount = random.choice([5, 10, 15])  # Небольшая порция                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_nuts = True                        else:            # Основной прием пищи (обед/ужин): белок + крупа/картофель + овощи            # 1. Добавляем белковый продукт (мясо или рыба)            protein_source = random.choice(['meat', 'fish']) if random.random() < 0.7 else 'none'                        if protein_source == 'meat' and meat_foods:                food = random.choice(meat_foods)                # Рассчитываем количество для получения примерно 30-50% от целевого белка                protein_fraction = random.uniform(0.3, 0.5)                amount_needed = (target_protein * protein_fraction * 100) / max(food.protein, 0.1)                # Округляем до ближайшего кратного 20                amount = min(max(20, (int(amount_needed // 20) * 20)), 160)                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_meat = True                meat_types.add(food.name)                            elif protein_source == 'fish' and fish_foods:                food = random.choice(fish_foods)                protein_fraction = random.uniform(0.3, 0.5)                amount_needed = (target_protein * protein_fraction * 100) / max(food.protein, 0.1)                amount = min(max(20, (int(amount_needed // 20) * 20)), 160)                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_fish = True                fish_count += 1                fish_types.add(food.name)                        # 2. Добавляем крупу/картофель (источник углеводов)            if grain_foods and not has_grain and grain_count == 0:                food = random.choice(grain_foods)                carb_fraction = random.uniform(0.3, 0.5)                carb_needed = target_carbs - current_carbs                amount_needed = (carb_needed * carb_fraction * 100) / max(food.carbs, 0.1)                amount = min(max(20, (int(amount_needed // 20) * 20)), 140)                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_grain = True                grain_count += 1                grain_types.add(food.name)                        # 3. Добавляем овощи            if vegetable_foods and not has_vegetable:                food = random.choice(vegetable_foods)                amount = random.choice([100, 150, 200])                                selected_foods.append((food, amount))                calorie_factor = amount / 100.0                current_calories += food.calories * calorie_factor                current_protein += food.protein * calorie_factor                current_fats += food.fats * calorie_factor                current_carbs += food.carbs * calorie_factor                has_vegetable = True
        
        # Проверяем дефицит по основным целям
        calories_deficit = target_calories - current_calories
        protein_deficit = target_protein - current_protein
        fats_deficit = target_fats - current_fats
        carbs_deficit = target_carbs - current_carbs
        
        # Если после добавления основных продуктов мы далеки от целевых значений,
        # пытаемся добавить сбалансированные продукты для коррекции
        available_foods = [f for f in unique_foods if not any(f.id == sf[0].id for sf in selected_foods)]
        random.shuffle(available_foods)
        
        # Максимум 6 продуктов в приеме пищи (для перекуса - максимум 3)
        max_foods = 3 if is_snack else 6
        
        while len(selected_foods) < max_foods and available_foods:
            food = available_foods.pop(0)
            
            # Проверяем совместимость
            can_add = True
            
            # Проверки для разных категорий продуктов
            if food.category_id in meat_category_ids:
                if has_meat or has_fish or food.name in meat_types:
                    can_add = False
                else:
                    has_meat = True
                    meat_types.add(food.name)
            elif food.category_id in fish_category_ids:
                if has_meat or fish_count >= 1:
                    can_add = False
                else:
                    has_fish = True
                    fish_count += 1
                    fish_types.add(food.name)
            elif food.category_id in grains_category_ids:
                if has_grain or grain_count >= 1 or food.name in grain_types:
                    can_add = False
                else:
                    has_grain = True
                    grain_count += 1
                    grain_types.add(food.name)
                    
            # Для перекуса добавляем только определенные категории продуктов
            if is_snack and not (food.category_id in dairy_category_ids or 
                               food.category_id in fruit_category_ids or 
                               food.category_id in nuts_category_ids):
                can_add = False
            
            if not can_add:
                continue
            
            # Определяем, какой макронутриент нужно скорректировать больше всего
            # Используем относительный дефицит (% от цели)
            protein_rel_deficit = protein_deficit / target_protein if target_protein > 0 else 0
            fats_rel_deficit = fats_deficit / target_fats if target_fats > 0 else 0
            carbs_rel_deficit = carbs_deficit / target_carbs if target_carbs > 0 else 0
            calories_rel_deficit = calories_deficit / target_calories if target_calories > 0 else 0
            
            # Если все цели почти достигнуты (в пределах 10%), прекращаем добавлять продукты
            if all(abs(d) < 0.1 for d in [protein_rel_deficit, fats_rel_deficit, carbs_rel_deficit, calories_rel_deficit]):
                break
            
            # Определяем размер порции в зависимости от категории продукта и дефицита
            if is_snack:
                # Для перекуса - небольшие порции
                if food.category_id in dairy_category_ids:
                    amount = random.choice([100, 150, 200])
                elif food.category_id in fruit_category_ids:
                    amount = random.choice([50, 100, 150])
                elif food.category_id in nuts_category_ids:
                    amount = random.choice([10, 15, 20])
                else:
                    amount = random.choice([20, 30, 50])
            else:
                # Для основного приема
                if protein_rel_deficit > 0.15 and food.protein > 5:
                    # Нужен белок
                    amount_needed = (protein_deficit * 0.5 * 100) / food.protein
                    amount = min(max(20, (int(amount_needed // 20) * 20)), 120)
                elif fats_rel_deficit > 0.15 and food.fats > 5:
                    # Нужны жиры
                    amount_needed = (fats_deficit * 0.5 * 100) / food.fats
                    amount = min(max(20, (int(amount_needed // 20) * 20)), 120)
                elif carbs_rel_deficit > 0.15 and food.carbs > 5:
                    # Нужны углеводы
                    amount_needed = (carbs_deficit * 0.5 * 100) / food.carbs
                    amount = min(max(20, (int(amount_needed // 20) * 20)), 120)
                else:
                    # Берем средний вес
                    amount = random.choice([20, 40, 60])
            
            if amount >= 10:  # Минимальная порция 10г
                calorie_factor = amount / 100.0
                new_calories = current_calories + food.calories * calorie_factor
                new_protein = current_protein + food.protein * calorie_factor
                new_fats = current_fats + food.fats * calorie_factor
                new_carbs = current_carbs + food.carbs * calorie_factor
                
                # Проверка на улучшение баланса макронутриентов
                # Мы хотим, чтобы добавление продукта улучшало общий баланс
                current_error = (
                    abs(calories_deficit / target_calories) * 1.5 + 
                    abs(protein_deficit / target_protein) + 
                    abs(fats_deficit / target_fats) + 
                    abs(carbs_deficit / target_carbs)
                ) / 4
                
                new_error = (
                    abs((target_calories - new_calories) / target_calories) * 1.5 + 
                    abs((target_protein - new_protein) / target_protein) + 
                    abs((target_fats - new_fats) / target_fats) + 
                    abs((target_carbs - new_carbs) / target_carbs)
                ) / 4
                
                # Если новая ошибка меньше текущей, добавляем продукт в список
                if new_error < current_error:
                    selected_foods.append((food, amount))
                    current_calories = new_calories
                    current_protein = new_protein
                    current_fats = new_fats
                    current_carbs = new_carbs
                    
                    # Обновляем информацию о дефиците
                    calories_deficit = target_calories - current_calories
                    protein_deficit = target_protein - current_protein
                    fats_deficit = target_fats - current_fats
                    carbs_deficit = target_carbs - current_carbs
        
        # Рассчитываем "фитнес" этой комбинации (насколько она близка к цели)
        # Меньшее значение = лучше
        fitness = (
            abs(current_calories - target_calories) / target_calories * 1.5 +  # Больший вес для калорий
            abs(current_protein - target_protein) / target_protein +
            abs(current_fats - target_fats) / target_fats +
            abs(current_carbs - target_carbs) / target_carbs
        ) / 4  # Среднее по всем параметрам
        
        population.append((selected_foods, fitness))
    
    # Сортируем популяцию по фитнесу (от лучшего к худшему)
    population.sort(key=lambda x: x[1])
    
    # Выводим информацию о лучшей комбинации продуктов
    best_combo, best_fitness = population[0] if population else ([], float('inf'))
    
    if best_combo:
        # Объединяем одинаковые продукты перед возвратом результата
        combined_foods = {}
        for food, amount in best_combo:
            if food.id in combined_foods:
                # Если продукт уже есть в списке, суммируем количество
                combined_foods[food.id]['amount'] += amount
            else:
                # Если продукта еще нет, добавляем его
                combined_foods[food.id] = {'food': food, 'amount': amount}
        
        # Преобразуем обратно в список кортежей (food, amount)
        final_combo = [(item['food'], item['amount']) for item in combined_foods.values()]
        
        # Еще раз проверяем правила совместимости в финальной комбинации
        has_meat = False
        has_fish = False
        has_grain = False
        fish_count = 0
        grain_count = 0
        meat_types = set()
        fish_types = set()
        grain_types = set()
        final_filtered_combo = []
        
        for food, amount in final_combo:
            should_add = True
            
            if food.category_id in meat_category_ids:
                if has_meat or has_fish or food.name in meat_types:
                    should_add = False
                else:
                    has_meat = True
                    meat_types.add(food.name)
            elif food.category_id in fish_category_ids:
                if has_meat or fish_count >= 1:
                    should_add = False
                else:
                    has_fish = True
                    fish_count += 1
                    fish_types.add(food.name)
            elif food.category_id in grains_category_ids:
                if has_grain or grain_count >= 1 or food.name in grain_types:
                    should_add = False
                else:
                    has_grain = True
                    grain_count += 1
                    grain_types.add(food.name)
                    
            if should_add:
                final_filtered_combo.append((food, amount))
        
        # Рассчитываем общие значения для объединенной комбинации
        total_calories = sum(food.calories * amount / 100.0 for food, amount in final_filtered_combo)
        total_protein = sum(food.protein * amount / 100.0 for food, amount in final_filtered_combo)
        total_fats = sum(food.fats * amount / 100.0 for food, amount in final_filtered_combo)
        total_carbs = sum(food.carbs * amount / 100.0 for food, amount in final_filtered_combo)
        
        print(f"Объединенная комбинация (было: {len(best_combo)}, стало: {len(final_filtered_combo)} продуктов):")
        print(f"Получено: Калории: {total_calories:.1f}, Белки: {total_protein:.1f}г, Жиры: {total_fats:.1f}г, Углеводы: {total_carbs:.1f}г")
        print(f"Отклонение: К: {abs(total_calories-target_calories)/target_calories*100:.1f}%, Б: {abs(total_protein-target_protein)/target_protein*100:.1f}%, Ж: {abs(total_fats-target_fats)/target_fats*100:.1f}%, У: {abs(total_carbs-target_carbs)/target_carbs*100:.1f}%")
        
        # Выводим информацию о объединенных продуктах
        for food, amount in final_filtered_combo:
            calorie_factor = amount / 100.0
            print(f"  • {food.name} ({amount}г): К: {food.calories * calorie_factor:.1f}, Б: {food.protein * calorie_factor:.1f}г, Ж: {food.fats * calorie_factor:.1f}г, У: {food.carbs * calorie_factor:.1f}г")
        
        return final_filtered_combo
    
    return best_combo
